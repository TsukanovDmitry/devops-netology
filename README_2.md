Домашнее задание к занятию "6.6. Troubleshooting"

Задача 1

Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:

напишите список операций, которые вы будете производить для остановки запроса пользователя

1. Поиск запроса
db.currentOp({ "active" : true, "secs_running" : { "$gt" : 180 }})
2. Принудительное завершение запроса
db.killOp(opid)

предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Использование метода maxTimeMS()



Задача 2

Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

сначала рост отношения записанных значений к истекшим
Redis блокирует операции записи
Как вы думаете, в чем может быть проблема?

При добавлении очередной реплики на Redis, был превышен лимит по памяти (maxmemory) и Redis начал блокировать записи.

Правки
```
Возможно дело в том, что в Redis забилась память истекшими ключами, которые еще не были удалены. И Редис стал блокировать запись чтобы произвести чистку, поскольку Редис однопоточное приложение.
Возможно есть смысл скорректировать параметр hz в redis.conf

 Not all tasks are performed with the same frequency, but Redis checks for
# tasks to perform according to the specified "hz" value.
#
# By default "hz" is set to 10. Raising the value will use more CPU when
# Redis is idle, but at the same time will make Redis more responsive when
# there are many keys expiring at the same time, and timeouts may be
# handled with more precision.
#
# The range is between 1 and 500, however a value over 100 is usually not
# a good idea. Most users should use the default of 10 and raise this up to
# 100 only in environments where very low latency is required.
```


Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:

InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

Скорее всего, из за того, что таблица стала слишком большой, и запросы стали очень долгими.

Решения:
1) Увеличить на сервере MySQL wait_timeout, max_allowed_packet, net_write_timeout и net_read_timeout
2) Создать индексы по таблице
3) Оптимизировать запросы. Возможно какие то возвращают по миллиону строк

Задача 4

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

postmaster invoked oom-killer

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

Вероятно, что серверу PostgreSQL выделено мало памяти, и ее попросту не хватает.

Необходимо увеличить параметр vm.overcommit_ratio. 
```
Ну если смысла шатать ядро PostgreSQL нету, тогда есть смысл пошатать хост PostgreSQL (добавить ОЗУ, процессор, настроить swap)
Либо снизить нагрузку на БД, скорректировав параметры
max_connections
shared_buffer
work_mem
effective_cache_size
maintenance_work_mem

PS Но вообще, в продакшнене, я ни разу не встречал ситуации чтобы PostgreSQL падал по OOM. Вероятно изначально был просчет нагрузки на БД, либо в БД происходит что-то, что очень сильно забивает память, а OOM не успевает ее чистить. Я думаю что прежде всего нужно понять причину такого сообщения
```
